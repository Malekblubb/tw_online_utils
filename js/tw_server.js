var dgram = require("dgram");
var events = require("events");
var bufferUtils = require("./buffer_utils");
var utils = require("./utils");
var sii = require("./serverinfo_index");

var requestHeader = new Buffer([0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff]);

// class
function TwServer() {
	// events
	var eventEmitter = new events.EventEmitter();

	var serverInfos = new Array();
	var addresses = new Array();

	// create socket
	var socket = dgram.createSocket("udp4");
	socket.bind(0, function() {
		console.log("Bound socket at: " + socket.address().address + ":" + socket.address().port);
	});
	socket.on("message", function(msg, rinfo) {
		parseMessage(msg, rinfo);
	});

	// create requestbuffer
	var requestBuffer = new Buffer([0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0, 0, 0, 0, 0]);
	new Buffer("gie39").copy(requestBuffer, requestBuffer.length - 5); // 9 is the token and should be autogenerated


	// privileged
	// events
	this.on = function(ev, callback) {
		eventEmitter.on(ev, callback);
	}

	this.addServer = function(address) {
		addresses.push(address);
	}

	this.getServerInfo = function() {
		return serverInfo;
	}

	this.getServerInfoAt = function(index) {
		return serverInfo[index];
	}

	this.sendRequests = function() {
		for(var i = 0; i < addresses.length; ++i) {
			socket.send(requestBuffer, 0, requestBuffer.length, addresses[i].port, addresses[i].address, function(err, bytes) {
				if(bytes === 15) console.log("Sent inforequest");
				else console.error("Error while sending inforequest: " + err);
			});
		}
	}

	// private
	function parseMessage(msg, rinfo) {
		console.log("Got a message from " + utils.addressToString(rinfo) + " (" + msg.length + "bytes)");
		if(msg.length <= 15) {
			console.error("Invalid message: message is to short");
			return;
		}
		if((msg.slice(0, 10).toString() != requestHeader.toString())
			|| (msg.toString().search("inf3") == -1)) {
			console.error("Invalid message: message header is not valid");
			return;
		}

		var addressStr = utils.addressToString(rinfo);
		serverInfos[addressStr] = new Array();
		console.log("Message seems to be valid, starting parse");

		// remove header
		msg = msg.slice(17, msg.length);

		// parse the content
		var start = 0, index = 1, infoEnd = 0;
		for(; ; ++index) {
			var end = bufferUtils.bufferSearch(0x00, msg, start);
			if(end === -1 || index == 10)
				break;
			serverInfos[addressStr][index] = msg.slice(start, end).toString();
			// console.log(serverInfo[index]);
			start = end + 1;
			infoEnd = start;
		}

		// parse the players
		if(serverInfos[addressStr][sii.numClients] != 0) {
			msg = msg.slice(infoEnd, msg.length);
			start = 0;
			index = 0;
			var playerIndex = 0; 
			serverInfos[addressStr].players = new Array();
			for(; ; ++index) {
				var end = bufferUtils.bufferSearch(0x00, msg, start);
				if(end == -1)
					break;
				
				if(index == 5) {
					index = 0;
					++playerIndex;
				}
				if(index == 0)
					serverInfos[addressStr].players[playerIndex] = new Array();
				serverInfos[addressStr].players[playerIndex][index] = msg.slice(start, end).toString();
				start = end + 1;
			}
		}

		console.log(serverInfos[addressStr].players[1][sii.clan]);

		


		// add the address manually
		serverInfos[addressStr][sii.address] = rinfo.address + ":" + rinfo.port;

		// tell the user that the serverinfo arrived
		eventEmitter.emit("gotInfo", serverInfos[addressStr]);
	}
}

TwServer.createServerListener = function(targetAddress) {
	return new TwServer(targetAddress);
}

module.exports = TwServer;
